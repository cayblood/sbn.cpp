/*
 * net.cpp - Implementation of sbn::Net class
 *
 * SBN - Simple Bayesian Networking library
 * Copyright (c) 2005 Carl Youngblood
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */


#include "sbn.h"


namespace sbn
{
	int Net::m_count = 0;

	/** Default Constructor
	 *
	 * Constructs a new network.  If a title for a network is not specified, it
	 * gets set to  Net1, Net2, etc.  depending on how many networks have already
	 * been created. Title is used to export network to a file--a feature that is
	 * still pending.
	 */
	Net::Net(const string& title)
	{
		if (m_count == 0)
		{
			// seed the random number generator
			srandom(time(0) * getpid());
		}
		m_count++;
		if (title.empty()) m_title = "Net" + std::to_string(m_count);
		else m_title = title;
	}


	Net::Net(const Net& net)
	{
		*this = net;
	}


	Net& Net::operator=(const Net& net)
	{
		if (this != &net)
		{
			m_title = net.m_title;
			m_nodes = net.m_nodes;
			m_evidence = net.m_evidence;
		}

		return *this;
	}


	void Net::add_node(Node *node)
	{
		m_nodes[node->get_name()] = node;
	}


	void Net::set_evidence(Event& e)
	{
		m_evidence = e;
	}


	// Used to compare the values inside a map, rather than the keys.
	// We use this below to get the most frequent state
	bool value_compare(const std::pair<string, int>& lhs,
	                   const std::pair<string, int>& rhs)
	{
		return lhs.second < rhs.second;
	}


	/** Returns the estimated posterior probability for the specified node based
	 * on previously-supplied evidence, using the Markov Chain Monte Carlo
	 * algorithm.  The MCMC algorithm generates each event by making a random
	 * change to the preceding event.  The next state is generated by randomly
	 * sampling a value for one of the nonevidence variables Xi, conditioned on
	 * the current values of the variables in the Markov blanket of Xi.  MCMC
	 * basically wanders randomly around the state space--the space of possible
	 * complete assignments--flipping one variable at a time, but keeping the
	 * evidence variables fixed.  The sampling process works because it settles
	 * into a "dynamic equilibrium" in which the long-run fraction of time spent
	 * in each state is exactly proportional to its posterior probability.
	 */
	StateProbabilityMap Net::query_node(string nodename)
	{
		map<string, int> state_frequencies;
		map<string, bool> nodes_visited;
		map<string, bool>::iterator nodes_visited_iter;
		ObservationMap observations;
		ObservationMap::iterator end, event_iter;
		string name;
		Event e = generate_random_event();
		NodeMap::iterator node_iter;

		for (int i = 0; i < MCMC_NUM_SAMPLES; ++i)
		{
			string state = e.get_node_state(nodename);
			state_frequencies[e.get_node_state(nodename)]++;
			nodes_visited.clear();

			observations = e.get_observations();
			end = observations.end();
			for (event_iter = observations.begin(); event_iter != end; ++event_iter)
			{
				name = event_iter->first;
				nodes_visited_iter = nodes_visited.find(name);

				// if this node is already set in the evidence or we've already
				// generated a random state for this node, skip over it
				if (m_evidence.has_node(name) ||
				    nodes_visited_iter != nodes_visited.end())
					continue;

				node_iter = m_nodes.find(name);
				if (node_iter != m_nodes.end())
				{
					e.set_node(name,
						node_iter->second->get_random_state_with_markov_blanket(e));
				}
				nodes_visited[name] = true;
			}
		}

		// normalize results
		StateProbabilityMap returnval;
		map<string, int>::iterator freq_iter;
		int magnitude = 0;

		for (freq_iter = state_frequencies.begin();
		     freq_iter != state_frequencies.end();
		     ++freq_iter)
		{
			magnitude += freq_iter->second;
		}

		for (freq_iter = state_frequencies.begin();
		     freq_iter != state_frequencies.end();
		     ++freq_iter)
		{
			name = freq_iter->first;
			returnval[name] = freq_iter->second / (double)magnitude;
		}

		return returnval;
	}


	/**
	 * Returns an event in which nodes that are not fixed by the evidence are set
	 * to random states whose frequencies (after repeated calls) are consistent
	 * with the network's joint probability distribution.
	 */
	Event Net::generate_random_event()
	{
		Event returnval = m_evidence;
		bool incomplete_evidence;
		string name;

		do
		{
			incomplete_evidence = false;
			for (NodeMap::iterator iter = m_nodes.begin();
		     	 iter != m_nodes.end();
		     	 ++iter)
			{
				name = iter->second->get_name();
				// skip this node if it is already set in the evidence
				if (m_evidence.has_node(name)) continue;

				if (iter->second->can_be_evaluated(returnval))
				{
					returnval.set_node(name, iter->second->get_random_state(returnval));
					continue;
				}
				incomplete_evidence = true;
			}
		} while (incomplete_evidence);

		return returnval;
	}
}
